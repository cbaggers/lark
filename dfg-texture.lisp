(in-package :lark)

(defun-g integrate-dfg-only ((n·v :float) (roughness :float))
  (let ((sample-count (uint 1024))
	(n (v! 0 0 1))
	(v (v! (sqrt (- 1s0 (* n·v n·v))) 0 n·v))
	(accum (v4! 0))
	(accum-weight 0s0))
    ;; Compute pre-integration
    (for (i (uint 0)) (< i sample-count) (++ i)
	 (let* ((u (hammersley-get-sample (uint i) (uint sample-count)))
		(h (importance-sample-ggx u roughness n))
		(l (- (* 2 (dot v h) h) v))
		(n·l (saturate (z l)))
		(n·h (saturate (z h)))
		(v·h (saturate (dot v h)))
		(g (ggx-geom-smith-correlated n·v n·l roughness)))
	   (%if (and (> n·l 0) (> g 0))
		(let ((g-vis (* g (/ (dot l h) (* n·h n·v))))
		      (fc (pow (- 1 v·h) 5)))
		  (incf (x accum) (* (- 1 fc) g-vis))
		  (incf (y accum) (* fc g-vis))))
	   ;; diffuse Disney pre-integration
	   (let ((u (fract (+ u (v2! 0.5)))))
	     (multiple-value-bind (l n·l pdf) (importance-sample-cos-dir u n)
	       (%if (> n·l 0)
		    (let ((l·h (saturate (dot l (normalize (+ v l)))))
			  (n·v (saturate (dot n v))))
		      (incf (z accum) (disney-diffuse
				       n·v n·l l·h (sqrt roughness)))))
	       (incf accum-weight 1s0)))))
    (* accum (/ 1s0 accum-weight))))

(defun-g dfg-texture ((uv :vec2))
  (let ((n·v (x uv))
	(roughness (y uv)))
    (integrate-dfg-only n·v roughness)))

(def-g-> dfg-texture-pass ()
  (pass-through-vert g-pt)
  (dfg-texture :vec2))
